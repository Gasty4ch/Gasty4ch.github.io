import { loadSlim } from '@tsparticles/slim';

let audioContext;
let audioSource; // AudioBufferSourceNode
let analyser;
let buffer; // Decoded audio buffer
let isPlaying = false;
let animationFrameId; // To cancel requestAnimationFrame
let particlesContainer; // This will hold the tsparticles instance

const imageWrapper = document.querySelector('.image-wrapper');

// Function to load the audio file
async function loadAudio() {
    // Create an AudioContext - cross-browser compatibility
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    
    // Create an AnalyserNode to get audio data
    analyser = audioContext.createAnalyser();
    analyser.fftSize = 256; // Smaller fftSize for more coarse-grained, faster updates

    try {
        // Fetch the audio file
        const response = await fetch(lexa.mp3);
        const arrayBuffer = await response.arrayBuffer();
        // Decode the audio data into an AudioBuffer
        buffer = await audioContext.decodeAudioData(arrayBuffer);
    } catch (error) {
        console.error('Error loading audio:', error);
    }
}

// Function to start or stop playback and toggle visualization
function togglePlayback() {
    if (!audioContext || !buffer) {
        console.warn("Audio not loaded yet or loading failed.");
        return;
    }

    if (isPlaying) {
        // Stop playback
        if (audioSource) {
            audioSource.stop(); // Stop the current source
            audioSource.disconnect(); // Disconnect from the analyser
            audioSource = null; // Clear reference
        }
        isPlaying = false;
        cancelAnimationFrame(animationFrameId); // Stop the visualization loop
        imageWrapper.classList.remove('visualizing'); // Remove visualizing class

        // Reset image styles to their default (non-visualizing) state
        document.documentElement.style.setProperty('--image-visualizer-scale', '1');
        document.documentElement.style.setProperty('--image-visualizer-shadow-spread', '30px'); // Original default
        document.documentElement.style.setProperty('--image-visualizer-shadow-opacity', '1.0'); // Original default
        document.documentElement.style.setProperty('--image-visualizer-rotate', '0deg'); // Reset rotation

        // Reset tsparticles to original state
        if (particlesContainer && particlesContainer.options) {
            particlesContainer.options.particles.size.value = { min: 1.5, max: 3.5 };
            particlesContainer.options.particles.opacity.value = { min: 0.2, max: 0.8 };
            particlesContainer.options.particles.move.speed = 0.5;
            particlesContainer.options.number.value = 80;
            // Reset color/links color to initial config color
            particlesContainer.options.particles.color.value = "#ADD8E6"; 
            particlesContainer.options.particles.links.color.value = "#ADD8E6"; 
            // particlesContainer.refresh(); // Not strictly necessary for option value changes, but can ensure update
        }

    } else {
        // Start playback
        audioSource = audioContext.createBufferSource();
        audioSource.buffer = buffer; // Set the audio buffer
        audioSource.connect(analyser); // Connect to the analyser
        analyser.connect(audioContext.destination); // Connect analyser to speakers

        audioSource.start(0); // Play from the beginning
        isPlaying = true;
        imageWrapper.classList.add('visualizing'); // Add visualizing class
        visualizeAudio(); // Start the visualization loop
        
        // Set up an event listener to stop visualization when the song ends
        audioSource.onended = () => {
            if (isPlaying) { // Ensure it's not already manually stopped
                togglePlayback(); // Stop playback and reset visualization
            }
        };
    }
}

const dataArray = new Uint8Array(analyser.frequencyBinCount);

// Main visualization loop
function visualizeAudio() {
    if (!isPlaying || !analyser) {
        return;
    }

    // Populate dataArray with frequency data
    analyser.getByteFrequencyData(dataArray);

    // Calculate an average amplitude from a relevant frequency range
    let sum = 0;
    // Focus on lower to mid-range frequencies for a good 'beat' detection
    const relevantFreqRange = Math.floor(analyser.frequencyBinCount * 0.5); 
    for (let i = 0; i < relevantFreqRange; i++) {
        sum += dataArray[i];
    }
    const averageAmplitude = sum / relevantFreqRange;
    const normalizedAmplitude = averageAmplitude / 255; // Normalize to a 0-1 range

    // --- Image Visualizer ---
    // Update CSS custom properties for dynamic styling based on amplitude
    document.documentElement.style.setProperty('--image-visualizer-scale', (1 + normalizedAmplitude * 0.06).toFixed(3)); // Scale from 1 to 1.06 for more effect
    document.documentElement.style.setProperty('--image-visualizer-shadow-spread', `${(20 + normalizedAmplitude * 40).toFixed(1)}px`); // Shadow spread from 20px to 60px
    document.documentElement.style.setProperty('--image-visualizer-shadow-opacity', (0.7 + normalizedAmplitude * 0.3).toFixed(2)); // Shadow opacity from 0.7 to 1.0
    document.documentElement.style.setProperty('--image-visualizer-rotate', `${(normalizedAmplitude * 5 - 2.5).toFixed(2)}deg`); // Oscillate rotation from -2.5 to 2.5 degrees

    // --- tsparticles Background Visualizer ---
    if (particlesContainer && particlesContainer.options) {
        const particleOptions = particlesContainer.options.particles;
        const numberOptions = particlesContainer.options.number;

        // Dynamically adjust particle properties based on normalizedAmplitude
        particleOptions.size.value = { 
            min: 1.5 + normalizedAmplitude * 4, // Min size up to 5.5
            max: 3.5 + normalizedAmplitude * 7 // Max size up to 10.5
        };
        particleOptions.opacity.value = { 
            min: 0.2 + normalizedAmplitude * 0.6, // Min opacity up to 0.8
            max: 0.8 + normalizedAmplitude * 0.2 // Max opacity up to 1.0
        };
        particleOptions.move.speed = 0.5 + normalizedAmplitude * 2.5; // Speed up to 3.0
        numberOptions.value = 80 + normalizedAmplitude * 200; // Number of particles up to 280

        // Dynamic particle and link color based on amplitude
        const particleHue = 200 + normalizedAmplitude * 40; // Shift from a blue (200) to slightly purplish (240)
        const particleSaturation = 80 + normalizedAmplitude * 20; // 80% to 100% saturation
        const particleLightness = 70 + normalizedAmplitude * 20; // 70% to 90% lightness
        
        particleOptions.color.value = `hsl(${particleHue}, ${particleSaturation}%, ${particleLightness}%)`;
        particleOptions.links.color.value = `hsl(${particleHue}, ${particleSaturation}%, ${particleLightness}%)`;
    }

    // Continue the animation loop
    animationFrameId = requestAnimationFrame(visualizeAudio);
}

// Modify loadParticlesConfig to store the instance globally
async function loadParticlesConfigAndStoreInstance() {
  await loadSlim(tsparticles);

  particlesContainer = await tsparticles.load({ // Store the instance here
    id: "tsparticles",
    options: {
      background: {
        color: {
          // Match the darkest part of the radial background for seamless blending
          value: "#05050A" 
        }
      },
      fpsLimit: 60,
      interactivity: {
        events: {
          onClick: {
            enable: false, // No interaction on click
            mode: "push"
          },
          onHover: {
            enable: true,
            mode: "repulse" // Particles move away on hover
          },
          resize: true
        },
        modes: {
          push: {
            quantity: 4
          },
          repulse: {
            distance: 150, // Slightly larger repulsion area for more impact
            duration: 0.5 // Slower repulsion
          }
        }
      },
      particles: {
        color: {
          // Light Blue, to harmonize with H1 gradient and create a softer, ethereal look
          value: "#ADD8E6" 
        },
        links: {
          color: "#ADD8E6", // Match particle color
          distance: 180, // Longer links
          enable: true,
          opacity: 0.15, // Even less opaque links for more subtlety
          width: 1
        },
        move: {
          direction: "none",
          enable: true,
          outModes: {
            default: "bounce"
          },
          random: true, // Random movement for more organic feel
          speed: 0.5, // Even slower movement for a calmer, floating effect
          straight: false
        },
        number: {
          density: {
            enable: true,
            area: 700 // Denser particle field
          },
          value: 80 // More particles
        },
        opacity: {
          value: { min: 0.2, max: 0.8 }, // Wider range for more varied visual depth
          animation: {
            enable: true,
            speed: 0.8, // Subtle fade in/out
            sync: false,
            startValue: "random",
            destroy: "none"
          }
        },
        shape: {
          type: ["circle", "square", "triangle", "star"], // Added more shapes for visual variety
          options: {
            star: {
              sides: 5 // Default for star, but good to be explicit
            }
          }
        },
        size: {
          value: { min: 1.5, max: 3.5 }, // Slightly smaller particles for a shimmering dust effect
          animation: {
            enable: true,
            speed: 2, // Subtle size changes
            sync: false,
            startValue: "random",
            destroy: "none"
          }
        }
      },
      detectRetina: true
    }
  });
}

// Ensure audio context is resumed on user interaction (required by most browsers)
document.addEventListener('click', () => {
    if (audioContext && audioContext.state === 'suspended') {
        audioContext.resume();
    }
}, { once: true }); // This listener will only fire once

// Add click event listener to the image wrapper
imageWrapper.addEventListener('click', togglePlayback);

// Initialize audio and particles when the script loads
loadAudio();
loadParticlesConfigAndStoreInstance();